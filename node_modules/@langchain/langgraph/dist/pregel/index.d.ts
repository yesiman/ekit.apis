import { Runnable, RunnableConfig, RunnableFunc } from "@langchain/core/runnables";
import { IterableReadableStream } from "@langchain/core/utils/stream";
import { All, BaseCheckpointSaver, BaseStore, CheckpointListOptions, CheckpointTuple } from "@langchain/langgraph-checkpoint";
import { BaseChannel } from "../channels/base.js";
import { PregelNode } from "./read.js";
import { ChannelWrite } from "./write.js";
import { Command } from "../constants.js";
import { PregelInterface, PregelParams, StateSnapshot, StreamMode, PregelInputType, PregelOutputType, PregelOptions } from "./types.js";
import { StrRecord } from "./algo.js";
import { RetryPolicy } from "./utils/index.js";
import { ManagedValueMapping, type ManagedValueSpec } from "../managed/base.js";
import { LangGraphRunnableConfig } from "./runnable_types.js";
type WriteValue = Runnable | RunnableFunc<unknown, unknown> | unknown;
export declare class Channel {
    static subscribeTo(channels: string, options?: {
        key?: string;
        tags?: string[];
    }): PregelNode;
    static subscribeTo(channels: string[], options?: {
        tags?: string[];
    }): PregelNode;
    static writeTo(channels: string[], kwargs?: Record<string, WriteValue>): ChannelWrite;
}
export type { PregelInputType, PregelOutputType, PregelOptions };
export declare class Pregel<Nn extends StrRecord<string, PregelNode>, Cc extends StrRecord<string, BaseChannel | ManagedValueSpec>, ConfigurableFieldType extends Record<string, any> = StrRecord<string, any>, InputType = PregelInputType, OutputType = PregelOutputType> extends Runnable<InputType | Command | null, OutputType, PregelOptions<Nn, Cc, ConfigurableFieldType>> implements PregelInterface<Nn, Cc, ConfigurableFieldType>, PregelParams<Nn, Cc> {
    static lc_name(): string;
    /** @internal Used for type inferrence */
    "~InputType": InputType;
    /** @internal Used for type inferrence */
    "~OutputType": OutputType;
    lc_namespace: string[];
    lg_is_pregel: boolean;
    nodes: Nn;
    channels: Cc;
    inputChannels: keyof Cc | Array<keyof Cc>;
    outputChannels: keyof Cc | Array<keyof Cc>;
    autoValidate: boolean;
    streamMode: StreamMode[];
    streamChannels?: keyof Cc | Array<keyof Cc>;
    interruptAfter?: Array<keyof Nn> | All;
    interruptBefore?: Array<keyof Nn> | All;
    stepTimeout?: number;
    debug: boolean;
    checkpointer?: BaseCheckpointSaver | false;
    retryPolicy?: RetryPolicy;
    config?: LangGraphRunnableConfig;
    store?: BaseStore;
    constructor(fields: PregelParams<Nn, Cc>);
    withConfig(config: RunnableConfig): typeof this;
    validate(): this;
    get streamChannelsList(): Array<keyof Cc>;
    get streamChannelsAsIs(): keyof Cc | Array<keyof Cc>;
    getGraphAsync(config: RunnableConfig): Promise<import("@langchain/core/runnables/graph").Graph>;
    /** @deprecated Use getSubgraphsAsync instead. The async method will become the default in the next minor release. */
    getSubgraphs(namespace?: string, recurse?: boolean): Generator<[string, Pregel<any, any>]>;
    getSubgraphsAsync(namespace?: string, recurse?: boolean): AsyncGenerator<[string, Pregel<any, any>]>;
    protected _prepareStateSnapshot({ config, saved, subgraphCheckpointer, }: {
        config: RunnableConfig;
        saved?: CheckpointTuple;
        subgraphCheckpointer?: BaseCheckpointSaver;
    }): Promise<StateSnapshot>;
    /**
     * Get the current state of the graph.
     */
    getState(config: RunnableConfig, options?: {
        subgraphs?: boolean;
    }): Promise<StateSnapshot>;
    /**
     * Get the history of the state of the graph.
     */
    getStateHistory(config: RunnableConfig, options?: CheckpointListOptions): AsyncIterableIterator<StateSnapshot>;
    /**
     * Update the state of the graph with the given values, as if they came from
     * node `as_node`. If `as_node` is not provided, it will be set to the last node
     * that updated the state, if not ambiguous.
     */
    updateState(inputConfig: LangGraphRunnableConfig, values: Record<string, unknown> | unknown, asNode?: keyof Nn | string): Promise<RunnableConfig>;
    _defaults(config: PregelOptions<Nn, Cc>): [
        boolean,
        StreamMode[],
        // stream mode
        string | string[],
        // input keys
        string | string[],
        LangGraphRunnableConfig,
        // config without pregel keys
        All | string[],
        // interrupt before
        All | string[],
        // interrupt after
        BaseCheckpointSaver | undefined,
        BaseStore | undefined,
        boolean
    ];
    /**
     * Stream graph steps for a single input.
     * @param input The input to the graph.
     * @param options The configuration to use for the run.
     * @param options.streamMode The mode to stream output. Defaults to value set on initialization.
     *   Options are "values", "updates", and "debug". Default is "values".
     *     values: Emit the current values of the state for each step.
     *     updates: Emit only the updates to the state for each step.
     *         Output is a dict with the node name as key and the updated values as value.
     *     debug: Emit debug events for each step.
     * @param options.outputKeys The keys to stream. Defaults to all non-context channels.
     * @param options.interruptBefore Nodes to interrupt before.
     * @param options.interruptAfter Nodes to interrupt after.
     * @param options.debug Whether to print debug information during execution.
     */
    stream(input: InputType | Command | null, options?: Partial<PregelOptions<Nn, Cc, ConfigurableFieldType>>): Promise<IterableReadableStream<PregelOutputType>>;
    protected prepareSpecs(config: RunnableConfig, options?: {
        skipManaged?: boolean;
    }): Promise<{
        channelSpecs: Record<string, BaseChannel<unknown, unknown, unknown>>;
        managed: ManagedValueMapping;
    }>;
    _streamIterator(input: PregelInputType | Command, options?: Partial<PregelOptions<Nn, Cc>>): AsyncGenerator<PregelOutputType>;
    /**
     * Run the graph with a single input and config.
     * @param input The input to the graph.
     * @param options The configuration to use for the run.
     * @param options.streamMode The mode to stream output. Defaults to value set on initialization.
     *   Options are "values", "updates", and "debug". Default is "values".
     *     values: Emit the current values of the state for each step.
     *     updates: Emit only the updates to the state for each step.
     *         Output is a dict with the node name as key and the updated values as value.
     *     debug: Emit debug events for each step.
     * @param options.outputKeys The keys to stream. Defaults to all non-context channels.
     * @param options.interruptBefore Nodes to interrupt before.
     * @param options.interruptAfter Nodes to interrupt after.
     * @param options.debug Whether to print debug information during execution.
     */
    invoke(input: InputType | Command | null, options?: Partial<PregelOptions<Nn, Cc, ConfigurableFieldType>>): Promise<OutputType>;
    private _runLoop;
}
